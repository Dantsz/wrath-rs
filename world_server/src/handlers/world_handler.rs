use anyhow::Result;
use crate::packet::*;
use crate::character::*;
use crate::opcodes::Opcodes;
use podio::{WritePodExt, LittleEndian};

pub async fn send_initial_world_states(character: &Character) -> Result<()>
{
    let (header, mut writer) = create_packet(Opcodes::SMSG_INIT_WORLD_STATES, 8);
    writer.write_u32::<LittleEndian>(character.map)?;
    writer.write_u32::<LittleEndian>(0)?; //zone
    writer.write_u32::<LittleEndian>(0)?; //area

    //hardcode for now, should be dynamic
    writer.write_u16::<LittleEndian>(2)?; //count of world states

    writer.write_u32::<LittleEndian>(3191)?; //arena season world state id
    writer.write_u32::<LittleEndian>(1)?; 
    writer.write_u32::<LittleEndian>(3901)?; //arena progress world state id
    writer.write_u32::<LittleEndian>(1)?; 

    send_packet_to_character(&character, header, &writer).await?;
    Ok(())
}

pub async fn send_world_state_update(character: &Character, world_state:u32, value:u32) -> Result<()>
{
    let (header, mut writer) = create_packet(Opcodes::SMSG_UPDATE_WORLD_STATE, 8);
    writer.write_u32::<LittleEndian>(world_state)?;
    writer.write_u32::<LittleEndian>(value)?;

    send_packet_to_character(&character, header, &writer).await?;
    Ok(())
}

pub async fn send_temp_dummy_hardcoded_update(character: &Character) -> Result<()>
{
    //This is super mega temporary
    //It's a hard-coded but valid packet, that will succesfully get the player out
    //of loading screen. Keep it around as reference, until a proper mechanism to
    //build up this packet has been created and can be sensefully filled in, to verify
    //that we can still enter the world, and as reference material. 
    //It was taken from https://www.ownedcore.com/forums/world-of-warcraft/world-of-warcraft-emulator-servers/wow-emu-questions-requests/390468-smsg_update_object-documentation.html

    let (header, mut writer) = create_packet(Opcodes::SMSG_UPDATE_OBJECT, 8);
    let content = &[0x01, 0x00, 0x00, 0x00,
    0x03,                   
    0x07, 0x01, 0x02, 0x03,
    0x04,                 
    0x21, 0x00,             // Update Flags -> Living | Self
    0x00, 0x00, 0x00, 0x00, // Movement Flags
    0x00, 0x00,             // Extra Movement Flags
    0x00, 0x00, 0x00, 0x00, // Fake Time Stamp
    0xcd, 0xd7, 0x0b, 0xc6, // x
    0x35, 0x7e, 0x04, 0xc3, // y
    0xf9, 0x0f, 0xa7, 0x42, // z
    0x00, 0x00, 0x00, 0x00, // o
    0x00, 0x00, 0x00, 0x00, // Fall Time

    0x00, 0x00, 0x80, 0x3f, // Walk Speed (1.0f)
    0x00, 0x00, 0x8c, 0x42, // Run Speed (70.0f -> really fast ^^)
    0x00, 0x00, 0x90, 0x40, // Run Back Speed (4.5f)
    0x00, 0x00, 0x00, 0x00, // Swim Speed (swimming isn't enabled so we set this speed to 0)
    0x00, 0x00, 0x00, 0x00, // Swim Back Speed (see Swim Speed)
    0x00, 0x00, 0x00, 0x00, // Fly Speed (flying isn't enabled so we set this speed to 0)
    0x00, 0x00, 0x00, 0x00, // Fly Back Speed (see Fly Speed)
    0x00, 0x0f, 0x49, 0x40, // Turn Speed - how fast a character can turn around z axis (3.1415405f)
    0x00, 0x00, 0x00, 0x00, // Pitch Rate (flying is disabled, so this is set to 0)

    0x2a, // Mask Size ((1326 + 31) / 32 = 42)
    0b00010111, 0x00, 0x80, 0x01,  0x01, 0x00, 0b11000000, 0x00,  0x18, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,

    0x01, 0x02, 0x03, 0x00,  // OBJECT_FIELD_GUID Low GUID [Required]
    0x00, 0x00, 0x00, 0x00,  // OBJECT_FIELD_GUID High GUID [Required]
    0x19, 0x00, 0x00, 0x00,  // OBJECT_FIELD_TYPE -> unit | player | object
    0x00, 0x00, 0x80, 0x3f,  // OBJECT_FIELD_SCALE_X 
    0x01, 0x01, 0x01, 0x01,  // UNIT_FIELD_BYTES_0 Race(Human), Class(Warrior), Gender(Female), PowerType(Rage)
    0x3c, 0x00, 0x00, 0x00,  // UNIT_FIELD_HEALTH 
    0x3c, 0x00, 0x00, 0x00,  // UNIT_FIELD_MAXHEALTH
    0x01, 0x00, 0x00, 0x00,  // UNIT_FIELD_LEVEL
    0x01, 0x00, 0x00, 0x00,  // UNIT_FIELD_FACTIONTEMPLATE [Required]
    0x0c, 0x4d, 0x00, 0x00,  // UNIT_FIELD_DISPLAYID (Human Female = 19724) [Required]
    0x0c, 0x4d, 0x00, 0x00];

    {
        use std::io::Write;
        writer.write(content)?;
    }

    send_packet_to_character(&character, header, &writer).await?;

    Ok(())
}


